#include <stdio.h> //this library is needed for printf function
#include <stdlib.h> //this library is needed for rand() function
#include <windows.h> //this library is needed for pause() function
#include <time.h> //this library is needed for clock() function
#include <math.h> //this library is needed for abs()
#include <omp.h> //this library is needed for the timer
#include <xmmintrin.h> // required for __m128
#include <immintrin.h> // required for __m256

unsigned short int equal(float a, float b); //in C, functions must be declared before main()
void init();
void q1();
void q2();
void q3();

void q1_vec();
void checkq1_vec();
void q2_vec();
void checkq2_vec();
void q3_vec();
void checkq3_vec();


#define N 256 //input size
#define EPSILON 1e-6 //relative error margin

float A[N][N], u1[N], u2[N], v1[N], v2[N], x[N], y[N], w[N], z[N];
float alpha = 0.23, beta = 0.45;


int main() {

	double start_1, end_1; //define the timers measuring execution time

	init();//initialize the arrays

	start_1 = omp_get_wtime(); //start the timer 

	//q1();
	//q1_vec();

	//q2();
	q2_vec();
	
	//q3();


	end_1 = omp_get_wtime(); //end the timer - timer checks that vec path is faster

	printf("Time in seconds is %f\n", end_1 - start_1 );//print the ex.time

	//checkq1_vec();
	checkq2_vec();

	system("pause"); //this command does not let the output window to close

	return 0; //normally, by returning zero, we mean that the program ended successfully. 
}


void init() {

	int i, j;

	for (i = 0; i < N; i++)
		for (j = 0; j < N; j++) {
			A[i][j] = 0.0f;

		}

	for (i = 0; i < N; i++) {
		u1[i] = (i % 9) * 0.22f;
		u2[i] = (i % 9) * 0.33f;
		v1[i] = (i % 9) * 0.44f;
		v2[i] = (i % 9) * 0.55f;
		w[i] = 0.0f;
	}

}


void q1() {

	for (int i = 0; i < N; i++) {
		w[i] = alpha * u1[i] + beta; // multiplies alpha by u1[i] and adds beta, stores in w[i]
	}								 // does this for each element in w and u
}

void q2() {

	int i, j;

	for (i = 0; i < N; i++) {
		for (j = 0; j < N; j++) {
			A[i][j] += u1[i] * v1[j] + u2[i] * v2[j];
		}
	}
}

void q3() {

	int i, j;

	for (i = 0; i < N; i++) {
		for (j = 0; j < N; j++) {
			w[i] += alpha * A[i][j] * u1[j];
		}
	}
}



void q1_vec() { // need to use fmadd instruction, dont need padding since N is multiple of 8
	__m256 num1, num2, num3, num4;
	num1 = _mm256_set1_ps(0.23f);
	num2 = _mm256_set1_ps(0.45f);
	for (int i = 0; i < N; i += 8) {
		num3 = _mm256_loadu_ps(&u1[i]); //load u1 values
		num4 = _mm256_fmadd_ps(num1, num3, num2); // multiply alpha (num1) and u1 (num3), add beta (num2), store in w (num4)
		_mm256_storeu_ps(&w[i], num4); //store result back to w
	}
}

void checkq1_vec() {
	bool correct = false;
	for (int i = 0; i < N; i++) {
		float expected = alpha * u1[i] + beta;
		if (equal(w[i], expected)) {
			correct = true;
		}
	}
	if (correct == true) {
		printf("All results are correct\n");
	} else {
		printf("Some results are incorrect\n");
	}
}

void q2_vec() {
	int i, j;
	__m256 num1, num2, num3, num4, num5;
	for (i = 0; i < N; i++) {
		num1 = _mm256_set1_ps(u1[i]); // moved out of inner loop - only have to load once per loop
		num3 = _mm256_set1_ps(u2[i]); // not sure of loadu or set1 is better/faster?

		for (j = 0; j < N; j += 8) {
			num2 = _mm256_loadu_ps(&v1[j]);
			num4 = _mm256_loadu_ps(&v2[j]);
			num5 = _mm256_loadu_ps(&A[i][j]);

			num1 = _mm256_mul_ps(num1, num2); // a * b = ab
			num3 = _mm256_fmadd_ps(num3, num4, num1); // c * d + ab = R
			num4 = _mm256_add_ps(num5, num3); // A[i][j] + R = Ans
			_mm256_storeu_ps(&A[i][j], num4); // store ans back into A
		} 
	}
}

void checkq2_vec() {
    bool all_correct = true;
    float expected[N][N] = { 0 };
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            expected[i][j] += u1[i] * v1[j] + u2[i] * v2[j];
            if (equal(A[i][j], expected[i][j]) != 0) {
                printf("Mismatch at A[%d][%d]: expected %f, got %f\n", i, j, expected[i][j], A[i][j]);
                all_correct = false;
            }
        }
    }
    if (all_correct) {
        printf("All results are correct\n");
    } else {
        printf("Some results are incorrect\n");
    }
}

void q3_vec() {

}

void checkq3_vec() {

}



//this function becomes problematic when b is zero or when both a and b are zero
unsigned short int equal(float a, float b) {
	float temp = a - b;

	if (fabs(temp / b) < EPSILON)
		return 0; //success
	else
		return 1; //wrong result
}


